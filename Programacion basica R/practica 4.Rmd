---
title: "practica4"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#EJERCICIO 1

```{r}
require(stats)
str(swiss)
head(swiss)
x <- swiss$Education[1:25]
x
sort(x, method="sh",index.return = TRUE) 
```


```{r}
#metodo sh ordena letras y numeros. Index return ($ix en la consola) me da la posición de cada valor
x <- as.integer(rnorm(200, 5, 7))
sort(x, method="quick")                        #metodo quick ordena numeros
```

Donde se puede sustituir "quick" por "qu" o por "q". A veces es interesante realizar la ordenación solo de una parte de los datos, esto puede hacerse con: sort(x, partial = 1:5), en este caso, devuelve el vector con las cinco primeras posiciones del vector ordenado pero el resto sin ordenar. En selección directa, corta el bucle cuando llega al cinco

Como podemos observar, los valores aparecen ordenados de menor a mayor. 

```{r}
sort(x, partial = 1:5)
```

Con partial ordenamos solo una parte de los datos, en este caso devolviendo el vector con las cinco primeras posiciones del vector ordenado pero el resto sin ordenar. En selección directa, corta el bucle cuando llega al cinco



#Ejercicio 2

calculamos las variables: 
```{r}
x<-as.integer(rnorm(100,42,(2.5**(1/2))))
x
y<-as.integer(rnorm(100,177,(10**(1/2))))
y
```


Metemos las variables en el dataframe datos
```{r}
datos<-data.frame(x,y)
datos
```


Calculamos la media y la varianza
```{r}
media<-lapply(datos,mean)
varianza<-lapply(datos,var)
media
varianza
```


Calculamos covarianza y correlacion
```{r}
covar<-cov(datos$x,datos$y)
corr<-cor(x,y,method = "pearson")
covar
corr
```


#Determinamos la regresion lineal entre variables y representamos los resultados
```{r}
msg<-sprintf("covariance = %.2g Correlation = %.2f", covar, corr)
plot(datos$x,datos$y,main=msg,
     xlab="datos x",
     ylab="datos y")
lmPR4<-lm(y~x)
abline(lmPR4)
```



#EJERCICIO 3

Calcular una matriz de k1 filas por k2 columnas con numeros aleatorios segun dist. de poisson de parametro lambda
```{r}
k1<-3
k2<-5
lambda<-5
x<-rpois(k1*k2,lambda)
x
```



forma facil
```{r}
mat<-matrix(x,nrow=k1,ncol=k2)      
mat
mat2<-mat
```



forma con bucles



hay qye crear un objeto aleatorio porque si la pones vacia el bucle cuando va al elemento 1,1 por ejemplo, se encontraría que la posición no existe y me daría mal resultado. 

Como vemos, el siguiente bucle completa la matriz incluyendo los elementos 1 a 1 por filas (K1):


```{r}
for(i in 1:k1){
        for(j in 1:k2){
                mat2[i,j]<-x[k2*(i-1)+j]    
        }
}
mat2
x
k2
```


matrix hace la matriz y mete los numeros por columnas. Con el bucle rellena por filas. si quiero que lo coloque como en matrix seria:

completando por columnas:

Como vemos, en este bucle los elementos del bucle anterior correspondientes a K2 y K1 cambian su orden de entrada al bucle. Como definimos al principio, K2 corresponde a columnas y por eso, en este caso, empezamos completando por K2. 

```{r}
mat3<-mat
for(j in 1:k2){
        for(i in 1:k1){
                mat3[i,j]<-x[k1*(j-1)+i]    #si queremos que nos salga como en matrix, habria que cambiar los bucles
        }
}
mat3
x
```


Calcular la matriz traspuesta:

1ºcreo una matriz de 0s con dimensiones k2 y k1
```{r}
mattrasp<-matrix(0,k2,k1)
mattrasp
```



2º
```{r}
for(i in 1:k2){
        for(j in 1:k1){
                mattrasp[i,j]<-mat2[j,i]}
}

```

Comprobamos los resultados utilizando la función t(x) de R y mirando mattrasp
```{r}
trasp.mat2<-t(mat2)
mattrasp
```

